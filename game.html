<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solana Golf Game ($SHUFF)</title>
  <script src="https://unpkg.com/@solana/web3.js@1.73.0/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.9/dist/browser/index.iife.min.js"></script>
  <style>
    body { 
      font-family: 'Arial', sans-serif;
      background: #f0f8ff;
      color: #333;
      text-align: center;
      padding: 20px;
      margin: 0;
    }
    
    .game-container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    h1 {
      color: #2c3e50;
      margin-bottom: 20px;
      font-size: clamp(1.5rem, 3vw, 2rem);
    }
    
    #game-canvas {
      background: #2ecc71;
      border-radius: 8px;
      margin: 20px auto;
      display: block;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      width: 100%;
      max-width: 800px;
      height: auto;
      aspect-ratio: 2/1;
    }
    
    #wallet-info {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      text-align: left;
    }
    
    .button-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s;
      flex: 1 0 auto;
      min-width: 120px;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    button:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    
    #swing-input-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      margin: 15px 0;
    }
    
    input {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
      min-width: 200px;
      flex: 1 0 auto;
    }
    
    #status {
      margin: 15px 0;
      min-height: 20px;
      color: #e74c3c;
      font-weight: bold;
    }
    
    #loading-spinner {
      margin: 20px 0;
    }
    
    .spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #leaderboard {
      background: #ecf0f1;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }
    
    #leaderboard-list {
      list-style: none;
      padding: 0;
      text-align: left;
    }
    
    #leaderboard-list li {
      padding: 8px;
      border-bottom: 1px solid #ddd;
    }
    
    #leaderboard-list li:last-child {
      border-bottom: none;
    }
    
    .tx-link {
      color: #3498db;
      text-decoration: none;
    }
    
    .tx-link:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 600px) {
      .button-group {
        flex-direction: column;
      }
      
      button {
        width: 100%;
      }
      
      #swing-input-container {
        flex-direction: column;
      }
      
      input {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>üèåÔ∏è Solana Golf Game ($SHUFF)</h1>
    
    <div class="button-group">
      <button id="connect-wallet-btn">Connect Phantom Wallet</button>
      <button id="disconnect-btn" disabled>Disconnect</button>
      <button id="refresh-btn">üîÑ Refresh</button>
    </div>

    <div id="wallet-info" style="display:none;">
      <p>Wallet Address: <span id="wallet-address"></span></p>
      <p>Balance: <span id="wallet-balance">0</span> SHUFF</p>
      <p id="last-tx-info" style="display:none;">Last TX: <a href="#" id="last-tx-link" class="tx-link" target="_blank">View</a></p>
    </div>

    <div id="swing-input-container">
      <input type="number" id="swing-amount" placeholder="Enter SHUFF amount" min="0.1" step="0.1">
      <button id="swing-btn" disabled>Swing!</button>
    </div>

    <div id="status"></div>
    <div id="fee-estimate" style="margin: 10px 0; color: #7f8c8d;"></div>

    <div id="loading-spinner" style="display:none;">
      <div class="spinner"></div>
      <p>Processing transaction...</p>
    </div>

    <canvas id="game-canvas"></canvas>

    <div id="leaderboard">
      <h2>üèÜ Leaderboard</h2>
      <ul id="leaderboard-list"></ul>
    </div>
  </div>

  <script>
    // Initialize SPL Token with robust fallback
    const splToken = window.splToken || {
      Token: solanaWeb3.SPLToken,
      getAssociatedTokenAddress: solanaWeb3.SPLToken.getAssociatedTokenAddress,
      createTransferInstruction: solanaWeb3.SPLToken.createTransferInstruction,
      createAssociatedTokenAccountInstruction: solanaWeb3.SPLToken.createAssociatedTokenAccountInstruction,
      getAccount: (accountInfo) => {
        return new solanaWeb3.SPLToken.Token(
          connection,
          shuffMint,
          solanaWeb3.TOKEN_PROGRAM_ID,
          null
        ).getAccountInfo(accountInfo.pubkey);
      }
    };
    
    // RPC Endpoints with fallback
    const endpoints = [
      solanaWeb3.clusterApiUrl('mainnet-beta'),
      'https://solana-mainnet.rpcpool.com',
      'https://api.mainnet-beta.solana.com'
    ];
    
    // Game Configuration
    const shuffMint = new solanaWeb3.PublicKey('GGnZQxAcBXvhKJFX7bRosBhbm8v4uFBeBuTnZsfapump');
    const treasuryWallet = new solanaWeb3.PublicKey('649fCzukZDSWwmhjQSAEJCyW6LXN8TDj5ytFxVtFv4ry');
    const liquidityPoolWallet = new solanaWeb3.PublicKey('BAHjp9xTpndjiD8mAP9PABd1UP8HQMgZRTyhFm73WJDC');
    
    // Game State
    let walletAddress = null;
    let walletPublicKey = null;
    let connection = null;
    let animationFrameId = null;
    let lastTransactionSignature = null;

    // DOM Elements
    const connectBtn = document.getElementById('connect-wallet-btn');
    const disconnectBtn = document.getElementById('disconnect-btn');
    const refreshBtn = document.getElementById('refresh-btn');
    const walletAddressSpan = document.getElementById('wallet-address');
    const walletBalanceSpan = document.getElementById('wallet-balance');
    const swingAmountInput = document.getElementById('swing-amount');
    const swingBtn = document.getElementById('swing-btn');
    const statusDiv = document.getElementById('status');
    const feeEstimateDiv = document.getElementById('fee-estimate');
    const loadingSpinner = document.getElementById('loading-spinner');
    const leaderboardList = document.getElementById('leaderboard-list');
    const lastTxInfo = document.getElementById('last-tx-info');
    const lastTxLink = document.getElementById('last-tx-link');

    // Initialize Connection
    async function initializeConnection() {
      for (const endpoint of endpoints) {
        try {
          const testConnection = new solanaWeb3.Connection(endpoint);
          await testConnection.getVersion();
          connection = testConnection;
          console.log("Connected to:", endpoint);
          return;
        } catch (err) {
          console.warn("Failed to connect to:", endpoint, err);
        }
      }
      throw new Error("Could not connect to any Solana RPC endpoint");
    }

    // Sanitize Input
    function sanitizeInput(input) {
      if (typeof input !== 'string') input = input.toString();
      return input.replace(/[<>"'&]/g, '');
    }

    // Connect Wallet
    async function connectWallet() {
      try {
        connectBtn.disabled = true;
        statusDiv.textContent = "Connecting to wallet...";
        
        if (!window.solana || !window.solana.isPhantom) {
          throw new Error("Phantom Wallet not installed!");
        }
        
        if (!connection) await initializeConnection();
        
        const response = await window.solana.connect();
        walletPublicKey = response.publicKey;
        walletAddress = walletPublicKey.toString();
        
        walletAddressSpan.textContent = `${walletAddress.slice(0,4)}...${walletAddress.slice(-4)}`;
        document.getElementById('wallet-info').style.display = 'block';
        swingBtn.disabled = false;
        connectBtn.textContent = "Wallet Connected";
        disconnectBtn.disabled = false;
        
        // Get balance
        const balance = await getShuffBalance(walletPublicKey);
        walletBalanceSpan.textContent = balance;
        
        statusDiv.textContent = "Wallet connected successfully!";
        statusDiv.style.color = "#2ecc71";
        
        // Load leaderboard
        loadLeaderboard();
      } catch (err) {
        statusDiv.textContent = `Error: ${err.message}`;
        statusDiv.style.color = "#e74c3c";
        connectBtn.disabled = false;
        console.error("Connection error:", err);
      }
    }

    // Disconnect Wallet
    async function disconnectWallet() {
      try {
        if (window.solana && window.solana.isPhantom) {
          await window.solana.disconnect();
        }
        walletAddress = null;
        walletPublicKey = null;
        walletAddressSpan.textContent = '';
        walletBalanceSpan.textContent = '0';
        document.getElementById('wallet-info').style.display = 'none';
        swingBtn.disabled = true;
        connectBtn.textContent = "Connect Phantom Wallet";
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        lastTxInfo.style.display = 'none';
        statusDiv.textContent = "Wallet disconnected";
        statusDiv.style.color = "#2ecc71";
      } catch (err) {
        statusDiv.textContent = `Error disconnecting: ${err.message}`;
        statusDiv.style.color = "#e74c3c";
        console.error("Disconnection error:", err);
      }
    }

    // Get SHUFF Token Balance
    async function getShuffBalance(publicKey) {
      try {
        const tokenAccount = await splToken.getAssociatedTokenAddress(
          shuffMint,
          publicKey
        );
        
        const accountInfo = await connection.getAccountInfo(tokenAccount);
        if (!accountInfo) return 0;
        
        const token = new splToken.Token(
          connection,
          shuffMint,
          solanaWeb3.TOKEN_PROGRAM_ID,
          null
        );
        
        const tokenAccountInfo = await token.getAccountInfo(tokenAccount);
        return (tokenAccountInfo.amount / 1000000000).toFixed(2);
      } catch (err) {
        console.error("Balance check error:", err);
        return 0;
      }
    }

    // Estimate Transaction Fees
    async function estimateFees(instructions) {
      try {
        const testTransaction = new solanaWeb3.Transaction().add(...instructions);
        const fees = await connection.getFeeForMessage(
          testTransaction.compileMessage(),
          'confirmed'
        );
        
        if (fees.value !== null) {
          feeEstimateDiv.textContent = `Estimated fee: ${fees.value} SOL`;
          feeEstimateDiv.style.color = "#7f8c8d";
        }
      } catch (err) {
        console.warn("Fee estimation failed:", err);
      }
    }

    // Send Transaction with 80/20 Split
    async function sendTransaction(amount) {
      loadingSpinner.style.display = 'block';
      statusDiv.textContent = "Preparing transaction...";
      
      try {
        // Validate amount
        if (amount <= 0) throw new Error("Amount must be positive");
        
        // Check token program
        if (!splToken || !splToken.Token) {
          throw new Error("Token program not properly initialized. Please refresh the page.");
        }
        
        // Check balance
        const balance = await getShuffBalance(walletPublicKey);
        if (amount > parseFloat(balance)) {
          throw new Error("Insufficient SHUFF balance");
        }
        
        // Calculate splits with precise math
        const treasuryAmount = Math.floor(amount * 100 * 0.8) / 100;
        const liquidityAmount = Math.floor(amount * 100 * 0.2) / 100;
        
        // Get token accounts
        const fromTokenAccount = await splToken.getAssociatedTokenAddress(
          shuffMint,
          walletPublicKey
        );
        
        const treasuryTokenAccount = await splToken.getAssociatedTokenAddress(
          shuffMint,
          treasuryWallet
        );
        
        const liquidityTokenAccount = await splToken.getAssociatedTokenAddress(
          shuffMint,
          liquidityPoolWallet
        );
        
        // Verify sender account exists
        const fromAccountInfo = await connection.getAccountInfo(fromTokenAccount);
        if (!fromAccountInfo) {
          throw new Error("You don't have a SHUFF token account");
        }
        
        // Create instructions
        const instructions = [];
        
        // Create associated token accounts if needed
        const treasuryAccountInfo = await connection.getAccountInfo(treasuryTokenAccount);
        if (!treasuryAccountInfo) {
          instructions.push(
            splToken.createAssociatedTokenAccountInstruction(
              walletPublicKey,
              treasuryTokenAccount,
              treasuryWallet,
              shuffMint
            )
          );
          statusDiv.textContent = "Creating token account (0.002039 SOL fee)...";
        }
        
        const liquidityAccountInfo = await connection.getAccountInfo(liquidityTokenAccount);
        if (!liquidityAccountInfo) {
          instructions.push(
            splToken.createAssociatedTokenAccountInstruction(
              walletPublicKey,
              liquidityTokenAccount,
              liquidityPoolWallet,
              shuffMint
            )
          );
          statusDiv.textContent = "Creating token account (0.002039 SOL fee)...";
        }
        
        // Add transfer instructions
        instructions.push(
          splToken.createTransferInstruction(
            fromTokenAccount,
            treasuryTokenAccount,
            walletPublicKey,
            BigInt(Math.floor(treasuryAmount * 1000000000))
          )
        );
        
        instructions.push(
          splToken.createTransferInstruction(
            fromTokenAccount,
            liquidityTokenAccount,
            walletPublicKey,
            BigInt(Math.floor(liquidityAmount * 1000000000))
          )
        );
        
        // Estimate fees
        await estimateFees(instructions);
        
        // Create transaction
        const recentBlockhash = await connection.getLatestBlockhash();
        const transaction = new solanaWeb3.Transaction({
          recentBlockhash: recentBlockhash.blockhash,
          feePayer: walletPublicKey
        }).add(...instructions);
        
        // Check transaction size
        if (transaction.serialize().length > 1232) {
          throw new Error("Transaction too large. Try a smaller amount.");
        }
        
        // Sign and send with timeout
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        
        try {
          const signed = await window.solana.signTransaction(transaction);
          const signature = await connection.sendRawTransaction(
            signed.serialize(),
            { abortSignal: controller.signal }
          );
          
          statusDiv.textContent = "Transaction sent, confirming...";
          const confirmation = await connection.confirmTransaction(
            signature,
            'confirmed'
          );
          
          if (confirmation.value.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
          }
          
          lastTransactionSignature = signature;
          lastTxLink.href = `https://solscan.io/tx/${signature}?cluster=mainnet-beta`;
          lastTxInfo.style.display = 'block';
          
          statusDiv.textContent = `üéâ Success! ${treasuryAmount.toFixed(2)} SHUFF to treasury, ${liquidityAmount.toFixed(2)} SHUFF to liquidity`;
          statusDiv.style.color = "#2ecc71";
          
          // Update balance
          const newBalance = await getShuffBalance(walletPublicKey);
          walletBalanceSpan.textContent = newBalance;
          
          // Animate golf swing
          animateGolfBall();
          
          // Update leaderboard
          updateLeaderboard(walletAddress, amount);
        } finally {
          clearTimeout(timeout);
        }
      } catch (err) {
        if (err.name === 'AbortError') {
          statusDiv.textContent = "Transaction timed out after 30 seconds";
        } else {
          statusDiv.textContent = `Transaction failed: ${err.message}`;
        }
        statusDiv.style.color = "#e74c3c";
        console.error("Transaction error:", err);
      } finally {
        loadingSpinner.style.display = 'none';
        feeEstimateDiv.textContent = '';
      }
    }

    // Golf Game Animation
    function animateGolfBall() {
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');
      
      // Adjust canvas size for display while maintaining aspect ratio
      const displayWidth = Math.min(canvas.width, window.innerWidth - 40);
      const displayHeight = displayWidth / 2;
      canvas.style.width = `${displayWidth}px`;
      canvas.style.height = `${displayHeight}px`;
      
      // Course elements
      const obstacles = [
        {x: 300, y: 250, width: 30, height: 30, type: 'sand'},
        {x: 500, y: 200, width: 40, height: 40, type: 'water'}
      ];
      
      // Ball properties
      const ball = {
        x: 50,
        y: 350,
        radius: 10,
        vx: swingAmountInput.value * 0.5,
        vy: -swingAmountInput.value * 0.8,
        inHole: false
      };
      
      // Hole properties
      const hole = {
        x: 700,
        y: 350,
        radius: 15
      };
      
      // Draw function
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw green
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(0, 350, canvas.width, 50);
        
        // Draw obstacles
        obstacles.forEach(obs => {
          ctx.fillStyle = obs.type === 'sand' ? '#f39c12' : '#3498db';
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        });
        
        // Draw hole
        ctx.beginPath();
        ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        
        // Draw ball if not in hole
        if (!ball.inHole) {
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
          ctx.fillStyle = 'white';
          ctx.fill();
          ctx.strokeStyle = '#333';
          ctx.stroke();
        }
      }
      
      // Update function
      function update() {
        if (ball.inHole) return;
        
        // Apply physics
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.vy += 0.2; // Gravity
        
        // Ground collision
        if (ball.y + ball.radius > 350) {
          ball.y = 350 - ball.radius;
          ball.vy *= -0.6; // Bounce
          ball.vx *= 0.9; // Friction
        }
        
        // Obstacle collisions
        obstacles.forEach(obs => {
          if (ball.x + ball.radius > obs.x && 
              ball.x - ball.radius < obs.x + obs.width &&
              ball.y + ball.radius > obs.y && 
              ball.y - ball.radius < obs.y + obs.height) {
            
            if (obs.type === 'water') {
              // Reset ball if in water
              ball.x = 50;
              ball.y = 350;
              ball.vx = ball.vy = 0;
              statusDiv.textContent = "üí¶ Ball in water! Try again.";
            } else {
              // Slow down in sand
              ball.vx *= 0.5;
              ball.vy *= 0.5;
            }
          }
        });
        
        // Hole detection
        const distToHole = Math.sqrt(
          Math.pow(ball.x - hole.x, 2) + 
          Math.pow(ball.y - hole.y, 2)
        );
        
        if (distToHole < hole.radius + ball.radius) {
          ball.inHole = true;
          statusDiv.textContent = "üèÜ Hole in one! You win!";
          updateLeaderboard(walletAddress, "WIN");
        }
        
        // Stop when slow enough
        if (Math.abs(ball.vx) < 0.1 && Math.abs(ball.vy) < 0.1) {
          ball.vx = ball.vy = 0;
        }
      }
      
      // Game loop
      function gameLoop() {
        update();
        draw();
        
        if (!ball.inHole && (ball.vx !== 0 || ball.vy !== 0)) {
          animationFrameId = requestAnimationFrame(gameLoop);
        }
      }
      
      // Cancel any existing animation
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Start the game
      gameLoop();
    }

    // Leaderboard Functions
    function loadLeaderboard() {
      try {
        const leaderboard = JSON.parse(localStorage.getItem('shuffLeaderboard') || '[]');
        displayLeaderboard(leaderboard);
      } catch (err) {
        console.error("Error loading leaderboard:", err);
        leaderboardList.innerHTML = '<li>Error loading leaderboard</li>';
      }
    }
    
    function updateLeaderboard(address, amount) {
      try {
        const sanitizedAmount = sanitizeInput(amount);
        const sanitizedAddress = sanitizeInput(address);
        
        const leaderboard = JSON.parse(localStorage.getItem('shuffLeaderboard') || '[]');
        leaderboard.push({
          address: sanitizedAddress,
          amount: sanitizedAmount,
          date: new Date().toISOString()
        });
        
        localStorage.setItem('shuffLeaderboard', JSON.stringify(leaderboard));
        displayLeaderboard(leaderboard);
      } catch (err) {
        console.error("Error updating leaderboard:", err);
      }
    }
    
    function displayLeaderboard(entries) {
      try {
        // Sort by date (newest first)
        entries.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // Get top 10
        const topEntries = entries.slice(0, 10);
        
        // Display with sanitized output
        leaderboardList.innerHTML = topEntries.map(entry => {
          const displayAmount = sanitizeInput(entry.amount);
          const displayAddress = sanitizeInput(entry.address);
          const displayDate = new Date(entry.date).toLocaleString();
          
          return `
            <li>
              <strong>${displayAddress.slice(0,4)}...${displayAddress.slice(-4)}</strong>
              - ${displayAmount} SHUFF
              <small>${displayDate}</small>
            </li>
          `;
        }).join('') || '<li>No entries yet</li>';
      } catch (err) {
        console.error("Error displaying leaderboard:", err);
        leaderboardList.innerHTML = '<li>Error displaying leaderboard</li>';
      }
    }

    // Event Listeners
    connectBtn.addEventListener('click', connectWallet);
    disconnectBtn.addEventListener('click', disconnectWallet);
    refreshBtn.addEventListener('click', () => {
      window.location.reload();
    });
    
    swingBtn.addEventListener('click', async () => {
      const amount = parseFloat(swingAmountInput.value);
      if (!amount || amount <= 0) {
        statusDiv.textContent = "Please enter a valid amount";
        statusDiv.style.color = "#e74c3c";
        return;
      }
      
      await sendTransaction(amount);
    });
    
    // Auto-connect if returning user
    window.addEventListener('load', async () => {
      try {
        if (window.solana && window.solana.isPhantom) {
          const response = await window.solana.connect({ onlyIfTrusted: true });
          walletPublicKey = response.publicKey;
          walletAddress = walletPublicKey.toString();
          
          walletAddressSpan.textContent = `${walletAddress.slice(0,4)}...${walletAddress.slice(-4)}`;
          document.getElementById('wallet-info').style.display = 'block';
          swingBtn.disabled = false;
          connectBtn.textContent = "Wallet Connected";
          disconnectBtn.disabled = false;
          
          const balance = await getShuffBalance(walletPublicKey);
          walletBalanceSpan.textContent = balance;
          
          loadLeaderboard();
        }
      } catch (err) {
        console.log("Auto-connect skipped:", err);
      }
      
      // Initialize connection
      if (!connection) {
        try {
          await initializeConnection();
        } catch (err) {
          statusDiv.textContent = "Error connecting to Solana network";
          statusDiv.style.color = "#e74c3c";
          console.error("Connection error:", err);
        }
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (animationFrameId) {
        const canvas = document.getElementById('game-canvas');
        const displayWidth = Math.min(canvas.width, window.innerWidth - 40);
        const displayHeight = displayWidth / 2;
        canvas.style.width = `${displayWidth}px`;
        canvas.style.height = `${displayHeight}px`;
      }
    });
  </script>
</body>
</html>
